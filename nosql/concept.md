#### Redis
**Redis 适用哪些场景**  
1. 会话缓存（session cache）
2. 全页缓存（FPC）
3. 队列
4. 排行榜/计数器
5. 发布/订阅

**Redis 集群写操作丢失**  
Redis并不能保证数据的强一致性，这意味着在实际中集群在特定的条件下可能会丢失写操作。

**Redis 内存优化**  
尽可能使用散列表（hashes），散列表使用的内存非常小，所以你可以尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称、姓氏、邮箱、密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。

##### Redis消息队列先进先出的注意事项  

通常使用一个List来实现队列操作，这样有一个小限制，所有的任务统一都是先进先出。如果想优先处理某个任务就不太好处理了，这就需要让队列有优先级的概念，可以优先处理高级别的任务。实现方式有：
1. 单一队列：队列正常的操作是左进右出（lpush, rpop），优先级高的任务直接插入到队头（rpush）
2. 使用两个队列，一个普通队列，一个高级队列。针对任务的级别放入不同的队列，获取任务时也很简单，Redis的BRPOP命令可以按顺序从多个队列中取值，BRPOP会按照给出的key顺序查看，并在找到的第一个非空List的尾部弹出一个元素
```cmd
redis> BRPOP list1 list2 0
```

##### Redis和Memcache的区别

|| Memcache | Redis |
| --- | --- | --- |
| 概念 | 数据存储在内存中，服务器断电则数据全部丢失；单个key存放的数据有1MB的限制；只能存储String字符串类型；本身没有持久化功能，可以使用多线程 | 数据类型丰富：String, List, Set, SortedSet, Hash；有持久化功能，可以把数据随时存放在磁盘上；本身有一定的计算功能；单个key存放存放的数据有1GB限制；只支持单线程 |
| 优化 | 1. -n(chunk 最小分配空间)设置为1024的整数倍；2. 不要存储超过1MB的数据，会拆分成多个chunk，计算和时间成本都成倍增加；3. 善用stats命令查看memcache的状态；4. 消灭eviction（被删除的数据）；5. 调整业务代码，提高命中率；6. 缓存小数据，节省带宽、网络IO时间、内存 | 1. 选择恰当的持久化方式：重写（BGREWRITEAOD）AOF文件；2. 内存优化：设置maxmemory，保持键名简短，使用短结构，对数据进行分片；3. 扩展读写能力：主从服务器，主写从读；4. 应用程序优化：尽可能减少操作Redis往返的通信次数 |
| 注意事项 | 1. key杜绝使用空格，长度控制在250个字符内。2. value <= 1MB, 必要时使用压缩。3. 失效时间0为永久有效，最大不超过30天，否则重新计算可能缓存只有1s |  |

##### Redis持久化方式及主从同步

持久化方式：
- RDB可以在指定的时间间隔内产生数据集的时间点快照
- AOF记录服务器所有的写操作，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF文件中的命令全部以Redis协议的格式来保存，新命令会被追加到文件末尾
- 同时使用RDB和AOF，这种情况，当Redis重启时，会优先使用AOF文件来还原数据，AOF保存的数据会比RDB更完整

同步：
从服务器向主服务器发送一个SYNC命令，接到SYNC命令的主服务器将开始执行BGSAVE，并在保存操作执行期间将所有新执行的命令都保存到一个缓冲区里，当BGSAVE执行完毕后，主服务器将执行保存操作所得到的 .rdb 文件发送给从服务器，从服务器接收到这个 .rdb文件并将文件中的数据载入到内存中，之后主服务器会以Redis命令协议的格式，将写命令缓冲区中积累的所有内容发送给从服务器。

**Redis 回收进程**  
1. 一个客户端运行了新的进程，添加了新的数据
2. Redis 检查内存使用情况，如果大于maxmemory的限制，则根据设定好的策略进行回收
3. 一个新的命令被执行
4. 不断超越内存限制的边界，通过不断达到边界然后不断回收到边界以下