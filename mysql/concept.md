#### 读写分离注意点
为保证数据库数据的一致性，所有对于数据库的更新操作都是针对主数据库的，但是读操作可以针对从数据库进行。大多数站点的数据库读比写操作更加密集，而且查询条件相对复杂，数据库的大部分性能消耗在查询操作上。
主从复制数据是异步完成的，这就导致主从数据库中的数据有一定的延迟，在读写分离的设计中必须要考虑这点。以博客为例，用户在登录后发表一篇文章，他需要马上看到自己的文章，但是对于其他用户来说可以允许延迟一段时间(1min/5min..)，不会造成什么问题。这时对于当前用户就需要读主数据库，对于其他访问量更大的外部用户可以读从数据库。
- 适当放弃一致性：在一些实时性要求不高的场合，我们可以适当放弃一致性要求。这样可以充分利用多种手段来提高系统吞吐量，例如：页面缓存、分布式数据缓存、数据库读写分离、查询数据搜索索引化。
- 可以通过程序控制：将强一致性要求的功能(存钱/取钱)的读写操作均指向主数据库，或者将写操作采用“双写”的方式实现；而弱一致性(最终一致性)要求的功能(更新微博（写）、金融账户查询（读）)而实现读写分离。

#### 水平分库分表切分规则  
1. range：从0～10000一个表，10001～20000一个表
2. hash取模：对用户ID进行取模，分配到不同的数据库/表
3. 地理区域
4. 时间：将6个月/一年前的数据分割出去
注：水平分表是将数据保存在同一库中，所以库级别还是会有IO瓶颈

#### 分库分表后面临的问题  
1. 事务支持
分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成逻辑上的事务，又会造成编程方面的负担。
 - 方案一：使用分布式事务
  - 优点：交由数据库管理，简单有效
  - 缺点：性能代价高，特别是shard越来越多时
- 方案二：由应用程序和数据库共同控制
 - 原理：将一个跨多个数据库的分布式事务拆分成多个仅处于单个数据库上面的小事务，并通过应用程序总控各个小事务
 - 优点：性能上有优势
 - 缺点：需要应用程序在事务控制上做灵活设计
2. 多库/表结果集合并（count，group by，order by）
解决方案：分别在各个节点上得到结果后通过应用程序进行合并，和join不同的是每个节点的查询可以并行执行，因此很多时候它的速度要比单一表快很多，如果结果集很大，对应用程序内存的消耗是一个问题。
3. 跨库/表 join
 - 全局表：有可能系统中所有模块都可能会依赖一些表（类似数据字典）。为了避免跨库join查询，可以将这类表在其他数据库中均保存一份，同时这类数据也很少发生修改，所以也不用太担心“一致性”问题
 - 字段冗余：避免join查询
 - 分两次查询，在第一次查询的结果集中找出关联数据ID，根据这些ID发起第二次请求得到关联数据。
 4. ID问题
 一旦数据库被切分到多个物理节点上，我们将不能再依赖数据库自身的主键生成机制